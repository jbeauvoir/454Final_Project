Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> regex
Rule 1     regex -> expression
Rule 2     regex -> empty
Rule 3     expression -> expression KLEENE
Rule 4     expression -> expression expression
Rule 5     expression -> L_PAREN expression R_PAREN
Rule 6     expression -> expression UNION expression
Rule 7     expression -> SYMBOL
Rule 8     empty -> <empty>

Terminals, with rules where they appear

KLEENE               : 3
L_PAREN              : 5
R_PAREN              : 5
SYMBOL               : 7
UNION                : 6
error                : 

Nonterminals, with rules where they appear

empty                : 2
expression           : 1 3 4 4 5 6 6
regex                : 0

Parsing method: LALR

state 0

    (0) S' -> . regex
    (1) regex -> . expression
    (2) regex -> . empty
    (3) expression -> . expression KLEENE
    (4) expression -> . expression expression
    (5) expression -> . L_PAREN expression R_PAREN
    (6) expression -> . expression UNION expression
    (7) expression -> . SYMBOL
    (8) empty -> .

    L_PAREN         shift and go to state 4
    SYMBOL          shift and go to state 5
    $end            reduce using rule 8 (empty -> .)

    regex                          shift and go to state 1
    expression                     shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> regex .



state 2

    (1) regex -> expression .
    (3) expression -> expression . KLEENE
    (4) expression -> expression . expression
    (6) expression -> expression . UNION expression
    (3) expression -> . expression KLEENE
    (4) expression -> . expression expression
    (5) expression -> . L_PAREN expression R_PAREN
    (6) expression -> . expression UNION expression
    (7) expression -> . SYMBOL

    $end            reduce using rule 1 (regex -> expression .)
    KLEENE          shift and go to state 7
    UNION           shift and go to state 8
    L_PAREN         shift and go to state 4
    SYMBOL          shift and go to state 5

    expression                     shift and go to state 6

state 3

    (2) regex -> empty .

    $end            reduce using rule 2 (regex -> empty .)


state 4

    (5) expression -> L_PAREN . expression R_PAREN
    (3) expression -> . expression KLEENE
    (4) expression -> . expression expression
    (5) expression -> . L_PAREN expression R_PAREN
    (6) expression -> . expression UNION expression
    (7) expression -> . SYMBOL

    L_PAREN         shift and go to state 4
    SYMBOL          shift and go to state 5

    expression                     shift and go to state 9

state 5

    (7) expression -> SYMBOL .

    KLEENE          reduce using rule 7 (expression -> SYMBOL .)
    UNION           reduce using rule 7 (expression -> SYMBOL .)
    L_PAREN         reduce using rule 7 (expression -> SYMBOL .)
    SYMBOL          reduce using rule 7 (expression -> SYMBOL .)
    $end            reduce using rule 7 (expression -> SYMBOL .)
    R_PAREN         reduce using rule 7 (expression -> SYMBOL .)


state 6

    (4) expression -> expression expression .
    (3) expression -> expression . KLEENE
    (4) expression -> expression . expression
    (6) expression -> expression . UNION expression
    (3) expression -> . expression KLEENE
    (4) expression -> . expression expression
    (5) expression -> . L_PAREN expression R_PAREN
    (6) expression -> . expression UNION expression
    (7) expression -> . SYMBOL

  ! shift/reduce conflict for KLEENE resolved as shift
  ! shift/reduce conflict for UNION resolved as shift
  ! shift/reduce conflict for L_PAREN resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
    $end            reduce using rule 4 (expression -> expression expression .)
    R_PAREN         reduce using rule 4 (expression -> expression expression .)
    KLEENE          shift and go to state 7
    UNION           shift and go to state 8
    L_PAREN         shift and go to state 4
    SYMBOL          shift and go to state 5

  ! KLEENE          [ reduce using rule 4 (expression -> expression expression .) ]
  ! UNION           [ reduce using rule 4 (expression -> expression expression .) ]
  ! L_PAREN         [ reduce using rule 4 (expression -> expression expression .) ]
  ! SYMBOL          [ reduce using rule 4 (expression -> expression expression .) ]

    expression                     shift and go to state 6

state 7

    (3) expression -> expression KLEENE .

    KLEENE          reduce using rule 3 (expression -> expression KLEENE .)
    UNION           reduce using rule 3 (expression -> expression KLEENE .)
    L_PAREN         reduce using rule 3 (expression -> expression KLEENE .)
    SYMBOL          reduce using rule 3 (expression -> expression KLEENE .)
    $end            reduce using rule 3 (expression -> expression KLEENE .)
    R_PAREN         reduce using rule 3 (expression -> expression KLEENE .)


state 8

    (6) expression -> expression UNION . expression
    (3) expression -> . expression KLEENE
    (4) expression -> . expression expression
    (5) expression -> . L_PAREN expression R_PAREN
    (6) expression -> . expression UNION expression
    (7) expression -> . SYMBOL

    L_PAREN         shift and go to state 4
    SYMBOL          shift and go to state 5

    expression                     shift and go to state 10

state 9

    (5) expression -> L_PAREN expression . R_PAREN
    (3) expression -> expression . KLEENE
    (4) expression -> expression . expression
    (6) expression -> expression . UNION expression
    (3) expression -> . expression KLEENE
    (4) expression -> . expression expression
    (5) expression -> . L_PAREN expression R_PAREN
    (6) expression -> . expression UNION expression
    (7) expression -> . SYMBOL

    R_PAREN         shift and go to state 11
    KLEENE          shift and go to state 7
    UNION           shift and go to state 8
    L_PAREN         shift and go to state 4
    SYMBOL          shift and go to state 5

    expression                     shift and go to state 6

state 10

    (6) expression -> expression UNION expression .
    (3) expression -> expression . KLEENE
    (4) expression -> expression . expression
    (6) expression -> expression . UNION expression
    (3) expression -> . expression KLEENE
    (4) expression -> . expression expression
    (5) expression -> . L_PAREN expression R_PAREN
    (6) expression -> . expression UNION expression
    (7) expression -> . SYMBOL

    UNION           reduce using rule 6 (expression -> expression UNION expression .)
    L_PAREN         reduce using rule 6 (expression -> expression UNION expression .)
    SYMBOL          reduce using rule 6 (expression -> expression UNION expression .)
    $end            reduce using rule 6 (expression -> expression UNION expression .)
    R_PAREN         reduce using rule 6 (expression -> expression UNION expression .)
    KLEENE          shift and go to state 7

  ! KLEENE          [ reduce using rule 6 (expression -> expression UNION expression .) ]
  ! UNION           [ shift and go to state 8 ]
  ! L_PAREN         [ shift and go to state 4 ]
  ! SYMBOL          [ shift and go to state 5 ]

    expression                     shift and go to state 6

state 11

    (5) expression -> L_PAREN expression R_PAREN .

    KLEENE          reduce using rule 5 (expression -> L_PAREN expression R_PAREN .)
    UNION           reduce using rule 5 (expression -> L_PAREN expression R_PAREN .)
    L_PAREN         reduce using rule 5 (expression -> L_PAREN expression R_PAREN .)
    SYMBOL          reduce using rule 5 (expression -> L_PAREN expression R_PAREN .)
    $end            reduce using rule 5 (expression -> L_PAREN expression R_PAREN .)
    R_PAREN         reduce using rule 5 (expression -> L_PAREN expression R_PAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for KLEENE in state 6 resolved as shift
WARNING: shift/reduce conflict for UNION in state 6 resolved as shift
WARNING: shift/reduce conflict for L_PAREN in state 6 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 6 resolved as shift
